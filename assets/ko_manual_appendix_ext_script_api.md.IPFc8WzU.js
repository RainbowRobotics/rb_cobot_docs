import{_ as t,c as a,o as e,U as s}from"./chunks/framework.eBaQoOKe.js";const m=JSON.parse('{"title":"외부 스크립트 제어 API","description":"","frontmatter":{"layout":"doc","outline":"deep"},"headers":[],"relativePath":"ko/manual/appendix/ext_script_api.md","filePath":"ko/manual/appendix/ext_script_api.md"}'),r={name:"ko/manual/appendix/ext_script_api.md"},p=s(`<h1 id="외부-스크립트-제어-api" tabindex="-1">외부 스크립트 제어 API <a class="header-anchor" href="#외부-스크립트-제어-api" aria-label="Permalink to &quot;외부 스크립트 제어 API&quot;">​</a></h1><h3 id="_1-개념" tabindex="-1">1. 개념 <a class="header-anchor" href="#_1-개념" aria-label="Permalink to &quot;1. 개념&quot;">​</a></h3><p>협동로봇 RB Series는 다양한 환경과 목적으로 운용될 수 있습니다. 다수의 RB Series 혹은 다른 시스템과 연동되어 사용될 수 있습니다.<br> 비전 시스템과 연동되어 이동 좌표를 실시간으로 변경하거나, 사용자가 기존에 사용하던 시스템의 한 부분으로 사용할 수도 있습니다.</p><p>주어진 태블릿 UI로 로봇을 제어할 수도 있지만, 사용자의 편의나 운용의 이점을 위해서 외부의 임의의 제어기로부터 로봇을 제어할 수 있는 방법을 제공합니다.<br></p><p>RB Series는 기본적으로 스크립트 명령을 받고 그 명령을 수행합니다.<br> 태블릿 UI로 태스크 모션을 작성하고, 그 파일의 스크립트를 차례대로 수행하는 것이 일반적인 운용방안이라면, 본 문서에서 설명하고자 하는 방법은 외부의 다른 디바이스로부터 명령어 스크립트를 입력 받아 해석하여 움직이는 방법입니다.</p><p>태블릿 UI에서 제공하던 IF, REPEAT 등의 제어 구문은 사용자가 외부 제어 디바이스에서 직접 구현하고, 로봇의 동작 명령어와 IO제어 명령어를 상황에 맞게 보내주어 로봇을 구동합니다.</p><p>본 문서에서는 위 개념으로 로봇을 구동하는 예제를 설명합니다.</p><h3 id="_2-외부-제어-스크립트-api" tabindex="-1">2. 외부 제어 스크립트 API <a class="header-anchor" href="#_2-외부-제어-스크립트-api" aria-label="Permalink to &quot;2. 외부 제어 스크립트 API&quot;">​</a></h3><p>본 문서에서 제공하는 스크립트의 설명은 외부 제어를 위한 전용 스크립트로 태블릿을 사용해 작성하는 “.wsl” 워크 문서의 스크립트와 유사해 보이지만 <strong>다릅니다.</strong><br> 워크 문서에는 “repeat”, “if-else”, “break” 등과 같은 흐름을 제어하는 구문이 들어가기 때문에 하나의 문장(statement)의 완성이 동작으로 직결되지 않고, 그 문장의 상위 문장도 완성되어야 합니다.</p><p>예를 들어, 동작 명령 안에 point 들이 존재한다고 하였을 때 다음과 같이 표현될 수 있습니다.</p><p>1 :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>move joint {</span></span>
<span class="line"><span>    point ( ) absolute 0.4, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0</span></span>
<span class="line"><span>    point ( ) absolute 0.4, 0.1, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>2 :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>move joint {</span></span>
<span class="line"><span>    point ( ) absolute 0.4, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0</span></span>
<span class="line"><span>        point ( ) absolute 0.4, 0.1, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0</span></span></code></pre></div><p>1과 2의 차이는 마지막에 “}”의 유무입니다.<br> 두 경우에서 point 문장은 완성이 되어 있습니다. 하지만 1과 달리 2는 point의 상위 문장인 move 문장이 완성되지 않았기 때문에 동작할 수 없는 구문이고, 파서(parser)는 문장이 완성되길 기다릴 것입니다.</p><p>3 :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>folder( ) {</span></span>
<span class="line"><span>    move joint {</span></span>
<span class="line"><span>    point ( ) absolute 0.4, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0</span></span>
<span class="line"><span>        point ( ) absolute 0.4, 0.1, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0</span></span>
<span class="line"><span>    }</span></span></code></pre></div><p>같은 논리로 3의 경우에도 파서는 folder 문장이 완성되길 기다리며 동작되지 않습니다.</p><p>위와 같이 여러 줄의 구문들이 완성되어야 동작하는 방법은 외부 제어 방법에는 적합하지 않습니다. 사용자는 외부 제어를 통해 명령을 보내는 순간 그 명령을 파싱(parsing)해서 동작하길 기대합니다. 여러 번의 명령을 보내서 그 명령들이 3과 같이 여러 줄의 문장들을 완성시켜 나가는 것을 원하지 않습니다.</p><p>그래서 외부 제어는 모든 명령이 한 문장으로 끝날 수 있도록 간결하게 구성되어 있습니다.<br> 대신에 흐름을 제어하는 구문이나 기타 불필요한 기능들을 제공하지 않습니다.<br> 워크 문서에 있던 “repeat”, “if-else”, “break”와 같은 구문이나 “wait”와 같은 구문들도 외부 제어를 수행하는 소프트웨어에서 자체적으로 해결하는 것이 구조상이나 논리상 더 적합하고 간결합니다.</p><p>우선 설명드릴 스크립트는 초기화, 종료, 동작모드 변경입니다.</p><ol><li>mc :</li></ol><table><tr><th>스크립트</th><td>mc jall init</td></tr><tr><th>설명</th><td>이 명령은 로봇 하드웨어를 초기화합니다.</td></tr><tr><th>예시</th><td>“mc jall init”</td></tr></table><ol start="2"><li>shutdonw :</li></ol><table><tr><th>스크립트</th><td>shutdown</td></tr><tr><th>설명</th><td>이 명령은 로봇 동작을 종료시키고, 전원을 내립니다.</td></tr><tr><th>예시</th><td>“shutdown”</td></tr></table><ol start="3"><li>pgmode :</li></ol><table><tr><th>스크립트</th><td>pgmode mode_type</td></tr><tr><th>설명</th><td>이 명령은 로봇의 동작 모드를 변경합니다.<br><br> mode_type을 통해서 동작 모드를 선택합니다.<br> 동작 모드에는 “real”과 “simulation”이 있습니다.<br> “real”에서는 동작 명령을 내릴 때 실제로 로봇이 움직입니다.<br> “simulation”에서는 동작 명령을 내릴 때 내부 레퍼런스만 변경되고,<br> 그 명령이 로봇을 움직이지는 않습니다.<br><br> 로봇을 처음 초기화 하였을 때 기본 모드는 “simulation” 모드입니다. </td></tr><tr><th>예시</th><td> “pgmode real”<br> “pgmode simulation” </td></tr></table><p>마지막으로 설명드릴 스크립트는 task 스크립트입니다.</p><h4 id="task" tabindex="-1">task <a class="header-anchor" href="#task" aria-label="Permalink to &quot;task&quot;">​</a></h4><table><tr><th>스크립트</th><td>task load work_file_name</td></tr><tr><th>설명</th><td>이 명령은 기존에 작성된 워크 파일을 로드합니다.<br><br> work_file_name에는 “.wsl” 파일의 이름이 사용됩니다.<br> 이때에 “.wsl”은 생략하고, 파일의 상대경로와 이름만 입력합니다.<br><br> 이 파일은 팬던트에 존재하는 파일이 아니라,<br> 팬던트를 통해서 한번이라도 제어반에 연결하여 로드 혹은 저장했었던 파일이어야 합니다.<br> 그렇기 때문에 팬던트가 연결되어 있지 않더라도 해당 파일을 로드할 수 있습니다. </td></tr><tr><th>예시</th><td> “task load test_file” </td></tr></table><table><tr><th>스크립트</th><td>task play option</td></tr><tr><th>설명</th><td>이 명령은 로드된 워크 파일을 실행합니다.<br><br> option에는 아무런 값이 들어가지 않거나 “once”가 입력될 수 있습니다.<br> option에 아무런 값을 주지 않으면 설정된 횟수만큼 워크파일을 실행합니다.<br> option에 “once”를 입력할 경우에 워크 파일은 단 한 번만 실행됩니다. </td></tr><tr><th>예시</th><td> “task play”<br> “task play once” </td></tr></table><table><tr><th>스크립트</th><td>task repeat num</td></tr><tr><th>설명</th><td>이 명령은 워크 파일을 실행할 경우의 반복 횟수를 지정합니다.<br><br> num에는 반복 횟수를 정수형으로 입력합니다.<br> 만약 num에 -1을 입력하면 무한대를 의미합니다.<br><br> 이 명령으로 설정한 반복 횟수는 배전반의 전원을 리붓 시키기 전까지 유지됩니다.<br> 그 이후에는 팬던트로 설정한 값으로 다시 치환됩니다. </td></tr><tr><th>예시</th><td> “task repeat 5”<br> “task repeat -1” </td></tr></table><table><tr><th>스크립트</th><td>task pause</td></tr><tr><th>설명</th><td>이 명령은 실행 중이던 로봇 동작을 일시정지 시킵니다.<br><br> 외부 제어를 통한 동작 명령과 “task play” 명령으로 인해 실행 중이던 워크 파일에<br> 모두 사용할 수 있습니다.<br><br> 일시 정지된 상태에서는 “task resume_a” 명령을 통해서 동작을 재개할 수 있습니다.<br><br> 로봇이 일시 정지된 상태일 때에는 동작이 끝난 것으로 생각하지 않기 때문에,<br> 외부 제어에서 다른 동작 명령을 주어도 무시됩니다. </td></tr><tr><th>예시</th><td> “task pause” </td></tr></table><table><tr><th>스크립트</th><td>task stop</td></tr><tr><th>설명</th><td>이 명령은 실행 중이던 로봇 동작을 정지 시킵니다.<br><br> 외부 제어를 통한 동작 명령과 “task play” 명령으로 인해 실행 중이던 워크 파일에<br> 모두 사용할 수 있습니다.<br><br> 동작이 정지된 상태에서는 “task resume_a”로 동작이 재개되지 않습니다.<br> 동작이 완전 종료된 상태입니다.<br><br> 동작을 정지 명령을 내리면 로봇이 빠른 동작을 하고 있던 중에 급격히 멈출 수 있습니다.<br> “task pause” 이후에 “task stop” 명령을 수행하기를 권장합니다. </td></tr><tr><th>예시</th><td> “task pause” </td></tr></table><table><tr><th>스크립트</th><td>task resume_a</td></tr><tr><th>설명</th><td>이 명령은 “task pause”나 워크 파일에서 alarm 혹은 debug 명령으로<br> 일시 정지된 로봇의 동작을 재개합니다. </td></tr><tr><th>예시</th><td> “task resume_a” </td></tr></table><table><tr><th>스크립트</th><td>task resume_b</td></tr><tr><th>설명</th><td>이 명령은 외부 충돌 감지로 인해 일시 정지된 로봇의 동작을 재개합니다.</td></tr><tr><th>예시</th><td> “task resume_b” </td></tr></table><p>외부 제어를 사용하기 위해서 제어반의 프로그램과 연결을 해야 합니다.</p><p>연결은 TCP/IP 통신을 사용하고, 해당하는 IP 주소는 팬던트에서 설정할 수 있습니다. 그리고 그 결과는 제어반의 LCD화면에 표시됩니다.<br></p><p>외부 제어를 위해 5000번과 5001번 포트가 열립니다.<br> 5000번 포트는 명령어를 받기 위한 포트이고, 5001번 포트는 로봇 상태를 나타내는 데이터를 요청받고 보내주는 역할을 위한 포트입니다.<br> 편의상 5000번 포트는 명령 포트라고 하고, 5001번 포트를 데이터 포트라고 하겠습니다.</p><p>명령 포트로는 앞에서 설명한 스크립트 명령어를 전송하면 됩니다.<br> 명령 포트에는 첫 명령어에 대한 필터가 있어서 시작이 “mc”, “pgmode” 등과 같은 앞서 설명한 스크립트 명령어가 아닐 경우에는 “The command is not allowed”라는 문구를 응답으로 보냅니다.<br> 정상적인 명령어로 시작되어 파서로 입력 문장을 넘겼을 경우에는 “The command was executed”라는 문구의 응답이 옵니다.</p><p>추가적으로 더 다양한 스크립트 명령어는 기술 문서 &gt; RB/Ui 스크립트를 참고 부탁드립니다.</p><p>데이터 포트로는 “reqdata” 라는 명령어를 보내면 그에 대한 응답으로 현대 로봇 상태에 대한 정보가 데이터 포트로 들어옵니다.<br> 해당 매뉴얼이 아닌 기술 문서 &gt; Request 데이터 구조 매뉴얼을 참고 부탁드립니다.</p>`,42),n=[p];function l(i,o,d,h,b,c){return e(),a("div",null,n)}const _=t(r,[["render",l]]);export{m as __pageData,_ as default};
